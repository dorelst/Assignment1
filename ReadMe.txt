The application that I design to meet the assignment requirements consist of 4 classes:
- Assigment1 contains the main() method and is used to launch the application
- DetectionNodeQues creates the storage objects for the detection nodes. It contains the logical clocks, ques and methods to manipulate the ques
- DetectionNodeProcessor is the one that do the work of the detection nodes, simulating the three actions (internal (create message, anomaly detection), sending and receiving) and the communication between the nodes
- Sampler is the class that takes samples of the logical clock values for each detection node and generates a screen report and saves it also in a text file. The report contains the samples and also all the events with their logical clocks attached for each detection node.

How it works:
- there are 6 threads, main one, the four detection nodes threads and the sampler thread. Main threads waits for the other 5 to finish and after it finishes, too.
- the number of iterations that each node do is controlled by numberOfIterations variable set in Assigment1 class (line 14). The simulations were done with 1 million iterations, but now the variable is set to 10,000.
- the timing of the sample collection is control by the step variable set in Sampler class (line 27). This is set now to 500.
- the type of event each node do on each step is randomly generated by generateTypeOfEvent method in DetectionNodeProcessor class (line 115)
- the arbitrary events are randomly generated by arbitraryFailure method in DetectionNodeProcessor class (line 81)
- each detection node has its own detectionNodeQue object where it stores each event and also its logical clock (processorQues variable).
- each detection node receives a list with the other three nodes ques objects in order to be able to send them messages (otherProcessorsQues variable)
- when all four detection nodes threads finish, the sampler class will print on screen and write in a file (Report.txt) the samples took for each node and its events journal.
